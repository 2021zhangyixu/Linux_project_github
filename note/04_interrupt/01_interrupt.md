# 基础概念

## 中断作用

1. 中断是指 `CPU` 正常运行期间，由**外部（硬件中断）**和**内部（软中断）**事件引起的一种机制。
2. 中断机制赋予了我们处理意外情况的能力，如果我们能充分利用这个机制，将能够同时完成多个任务，从而**提高并发处理能力和资源利用率**。

## 中断的层级划分

1. 一个完整的中断子系统包括四个层次 : 

   - **用户层** : 该层是中断的使用者，主要**包含各类设备驱动，这些驱动程序通过中断相关 `API` 进行中断的申请和注册**。当外设触发中断时，用户层驱动程序也会进行相应的回调处理，执行特定的操作。**这一层是驱动工程师日常使用的**。
   - **通用层（框架层）** : 与硬件无关的层次。该层提供统一个接口和功能，用于管理和处理中断，使得驱动程序能够在不同的硬件平台上复用。**这一层主要是 Linux 内核开发者负责**。
   - **硬件相关层** : 该层包含两部分代码，处理器架构相关代码和中断控制器驱动代码。**这一层是原厂工程师负责**。
   - **硬件层** : 硬件层位于最底层，与具体的硬件连接相关。包含外设与 `SOC` 的物理连接。硬件层的设计和实现决定了中断信号的传递方式和硬件的处理能力。

   ![interrupt_arch](./img/irq_arch.png)

## 抢占机制

1. `Linux` **不支持中断嵌套**。因为如果出现了突发事件，**多个中断短时间同时触发，会导致多层中断嵌套，栈会极速增大，最终栈溢出**。
2. 虽然 `Linux` 不支持中断嵌套，但是一些 **`GIC` 控制器会支持抢占**。如果低优先级任务已经进入了 `CPU` ，高优先级任务依旧只能等着。但是如果低优先级任务还没进入 `CPU` ，此时 `GIC` 又来了一个高优先级任务，最终 `GIC` 会将高优先级任务传递给 `CPU`。
3. 因此，我们可以得出结论 : 

   - 高优先级中断无法抢占**正在执行**的低优先级中断。
   - 都是处于 **`pending` 状态**的中断，优先级高的中断先执行。
   - **同优先级，同 `pending`** 状态，选择**硬件中断号 IO 最小**的一个发给 `CPU` 执行。

## 中断上下文

1. 中断执行需要快速响应，但并不是所有的中断都可以迅速完成。而 **`Linux` 中不支持中断嵌套，意味着正式处理中断前就会屏蔽其他的中断**，直到中断处理完成后才重新允许中断。
2. 如果**中断执行时间过长就会导致部分中断无法被响应，可能导致死机**。为了解决这个问题，中断分为上下段。上段执行时间短，且需要尽快执行的事情。下段为一些相对耗时较长的事情。
3. **上半部是不能被中断的，下半部可被中断**。
4. 上半部是由**硬件请求**，也就是我们常说的**硬中断**，特点是快速执行。下半部是由**内核触发**，也就是我们常说的**软中断**，特点是延迟执行。
7. 下半段可通过**软中断** ，**`tasklet`**，**工作队列**来实现的。**`tasklet` 是基于软中断实现的**。

## 下半部实现

1. 中断上半部执行时间要短。而部分中断任务无法短时间完成，因此 `Linux` 将中断分为中断上半部和中断下半部。
2. 我们可以根据自己的需求选取中断下半部 : 
   - **软中断** : 软中断的**资源有限**，对应的中断号不多，一般用在**网络设备驱动**、**块设备驱动**当中。
   - **`Tasklet`** : **轻量级**的、需要**较高优先级**的任务。
   - **共享工作队列** : 需要**指定延时处理时间**的任务。
   - **自定义工作队列** : 需要**指定延时处理时间**并且需要**隔离/特殊配置**的任务。
   - **中断线程化** : **无需高优先级，无需指定延时处理时间**的任务。

## 中断号

1. 每个中断都有一个**软件中断号**（中断线，`IRQ Number`），通过中断号（中断线）可以区分不同中断，**在 Linux 内核中使用一个 int 变量表示中断号**。我们在驱动程序中利用中断号（中断线，`IRQ Number`）与指定的处理函数进行绑定。
2. 中断还有一个**硬件中断号**（`HW interrupt ID`），从驱动代码角度，我们只需要看中断号（中断线，`IRQ Number`）即可。但是**在设备树中配置的是硬件中断号（`HW interrupt ID`）**。所以在设备树中，我们需要设置**所属中断控制器**和 `IRQ` 号。

```dts
/{
    &uart1 {
        status = "okay";
        interrupts = <0 29 4>;  // 0 是中断控制器，29 是 IRQ 号，4 是触发方式
    };
};
```

3. 如果我们**只有一个中断控制器，软件中断号和硬件中断号是一一对应的**。但如果发生了如下这种**级联情况，那么就可能出现重复的硬件中断号**。如果 `CPU` 希望知道到底是那个中断事件，就还需要增加一个中断控制器的内容，通过**中断控制器**和**硬件中断号**配合在一起才可以知道到底是哪个中断。

![interrupt_id](./img/irq_id.png)

3. **将硬件中断号和软件中断号进行分离的好处是 : 一旦中断相关的硬件发生变化，驱动程序无需再进行调整**。Linux 内核会帮我们做硬件中断号和软件中断号的映射。

## 未处理中断/虚假中断

1. **虚假中断**是指系统检测到中断信号，但实际上并没有发生需要处理的中断事件。换句话说，系统进入了中断服务例程（ISR），但 ISR 找不到任何需要处理的实际任务。发生虚假中断的情况 : 
   - **信号干扰**：由于电气噪声或其他硬件故障，设备可能误发中断信号。
   - **共享中断线**：多个设备共用一个中断线（如 `PCI` 总线中的共享 `IRQ`），一个设备中断处理完成后可能导致中断信号没有及时清除，从而误触发其他设备的中断。
   - **中断控制器问题**：某些中断控制器（如 8259 PIC）在处理低优先级中断时，可能会错误地生成虚假中断信号。
2. 虚假中断会导致**CPU 占用率上升，性能下降**的问题。
3. **未处理中断**是指系统检测到中断信号并进入中断上下文，但没有找到对应的中断处理程序（ISR）来处理这个中断。结果，中断信号未能被清除，可能会重复触发。
   - **未注册中断处理程序**：设备驱动程序未能正确注册中断处理程序，导致中断信号无法被识别。
   - **中断号错误**：驱动程序请求了错误的中断号（`IRQ`），导致实际中断发生时找不到对应的处理程序。
   - **驱动程序错误**：驱动程序未正确清除中断状态，导致中断被多次重复触发。
4. 未处理中断会导致**设备不可用**、**系统崩溃**、**中断风暴（未清除的中断信号可能反复触发）**。
5. 为了处理如上问题，`Linux kernel` 做了对应的保护 : 如果同一个 `IRQ` 触发了 100,000 次，但是其中的 99,900 次没有被处理，那么 `kernel` 就会自己将这条中断线 `disable` 。

# API 介绍

### 获取中断号

1. 当我们知道 `GPIO` 引脚编号时，可以利用如下 `API` 将引脚编号转换为中断号。
2. 我们还可以在设备树中获取中断号信息，其方法在 [devicetree](./devicetree.md) 中的 `irq_of_parse_and_map()` 函数获取。

| 类型   | 描述                                                       |
| ------ | ---------------------------------------------------------- |
| 作用   | 将 `GPIO` 引脚编号转换成对应的中断请求号                   |
| `gpio` | 要映射的 `GPIO` 引脚号                                     |
| 返回值 | 成功时，返回与该 `GPIO` 引脚关联的 `IRQ` 编号;否则返回负数 |

```c
int gpio_to_irq(unsigned int gpio);
```

### 硬中断的注册与销毁

1. 在 `Linux` 内核中，使用中断需要为其申请额外资源（如分配内存、初始化中断向量等），如果此时资源不可用，**`request_irq` 可能会睡眠，直到资源可用为止**。
2. 正因上面的原因，所以 `request_irq` 不能在**中断上下文**或者**其他禁止睡眠的代码段**中调用。
3. `request_irq` 是 Linux 内核中用于请求一个中断服务程序（Interrupt Service Routine, ISR）的函数，它**将一个中断号（IRQ）与一个指定的处理函数绑定**，以便在硬件中断发生时触发该处理函数。

| 类型      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| 作用      | 将中断号和指定处理函数进行绑定                               |
| `irq`     | 需要注册的中断号，用于标识中断源                             |
| `handler` | 指向中断处理程序的函数指针，当发生中断之后就会执行该函数     |
| `flags`   | 中断触发方式及其他配置，常见的标志 : <br /> - `IRQF_SHARED` : 共享中断。**多个设备共享一个中断线**，共享的所有中断都必须指定该标志，并且 `dev` 参数就是用于区分不同设备的唯一标识。<br />- `IRQF_ONESHOT` : **单次中断**，中断只执行一次。<br />- `IRQF_TRIGGER_NONE` : **不依赖外部信号触发**。可能是定时器触发，也可是软件触发。<br />- `IRQF_TRIGGER_RISING` : **上升沿触发**。<br />- `IRQF_TRIGGER_FALLING` : **下降沿触发**。<br />- `IRQF_TRIGGER_HIGH` : **高电平触发**。<br />- `IRQF_TRIGGER_LOW` : **低电平触发**。 |
| `name`    | 中断名称，用于标识中断，我们可以利用 `cat /proc/interrupts` 命令进行查看 |
| `dev_id`  | 如果 `flags` 被设置为了 `IRQF_SHARED`，该参数就是用于区分不同的中断。**该参数也将会被传递给中断处理函数 `irq_handler_t` 的第二个参数**。 |
| 返回值    | 申请成功返回0，否则为负数                                    |

```c
int request_irq(unsigned int irq, irq_handler_t handler,
                unsigned long flags, const char *name, void *dev);
```

4. 当我们需要注销之前通过 `request_irq()` 注册的中断处理程序，就可以调用如下函数。

| 类型     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 作用     | 注销之前通过 `request_irq()` 注册的中断处理程序，并销毁中断注册时所产生的相关系统资源 |
| `irq`    | 需要注销的中断号                                             |
| `dev_id` | 如果该中断为共享中断，那么利用此参数区分具体中断，其值与 `request_irq()` 函数的最后一个参数 `dev_id` 一致。如果`request_irq()` 函数的最后一个参数 `dev_id` 传入值为 `NULL` ，那么这里也传入 `NULL` 即可。 |
| 返回值   | 无                                                           |

```c
void free_irq(unsigned int irq, void *dev_id);
```

### 中断服务程序（上半部）

| 类型     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 作用     | `request_irq()` 注册的中断处理函数。**该函数为中断上半部**。 |
| `irq`    | 中断处理函数对应的中断号。因为**有可能多个中断共享一个中断处理函数，因此可以利用该参数进行区分不同的中断源**。 |
| `dev_id` | 与 `request_irq()` 函数的最后一个参数 `dev_id` 一致。**用于区分共享中断的不同设备，该参数也可以指向设备结构体**。 |
| 返回值   | 返回一个 `irqreturn_t` 类型参数，其内容如下 :<br />- `IRQ_NONE` : 中断未被处理<br />- `IRQ_HANDLED` : 中断已被成功处理<br />- `IRQ_WAKE_THREAD` : 还需要中断下半部进一步处理 |

```c
irqreturn_t handler(int irq, void *dev_id);

enum irqreturn {
	IRQ_NONE		= (0 << 0),
	IRQ_HANDLED		= (1 << 0),
	IRQ_WAKE_THREAD		= (1 << 1),
};

typedef enum irqreturn irqreturn_t;
```

# 综合示例

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/gpio.h>
#include <linux/interrupt.h>

#define GPIO_PIN 112

static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
{
    printk("This is irq_handler\n");
    return IRQ_HANDLED;
}

static int __init interrupt_init(void)
{
    int irq_num;

    irq_num = gpio_to_irq(GPIO_PIN);

    if (request_irq(irq_num, gpio_irq_handler, IRQF_TRIGGER_RISING, "irq_test", NULL) != 0) {
        gpio_free(GPIO_PIN);
        return -ENODEV;
    }
    return 0;
}

static void __exit interrupt_exit(void)
{
    int irq_num = gpio_to_irq(GPIO_PIN);

    free_irq(irq_num, NULL);
    printk(KERN_INFO "GPIO Interrupt Driver exited successfully\n");
}

module_init(interrupt_init);
module_exit(interrupt_exit);

MODULE_LICENSE("GPL");
```





